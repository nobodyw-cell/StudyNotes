# 1. 复杂的分析

1.   复杂度的大O表示法

     1.   大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**

     2.   空间复杂度：**渐进空间复杂度**（asymptotic space complexity），**表示算法的存储空间与数据规模之间的增长关系**。
     3.   快排归并是nlogn

2.   最好时间复杂度

3.   最坏时间复杂度

4.   平均时间复杂度 （求期望？）

5.   均摊时间复杂度

# 2. 数组

为什么下标从零开始，对于c中的数组来说，下标其实是相对与数组头部的偏移量，当然a[0]就是a+0就是数组头部喽

# 3. 链表

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

LRU缓存淘汰算法（没啥说的就是将很长时间不用的淘汰掉）

链表实现判断字符串是否为回文

1.   快慢指针找出中间节点（慢指针前进的时候让next指针反转）
2.   从中间节点向两边沿申

哨兵模式，就是带头节点的链表head指向的节点不存数据

练了以下的题

1.   单链表反转

